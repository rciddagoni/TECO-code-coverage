{
  "name": "Teco test coverage",
  "tagline": "Python based test coverage tool for web applications",
  "body": "# WHAT IS THIS?\r\n \r\nThis is a project I created in my spare time to measure selenium test coverage for web apps. As QA Engineer I currently write automated tests and I needed a tool that instruments javascript and html files. The tool needed to work well with selenium tests (open browser-click through app-close browser).\r\nThere are some code and test coverage tools out there but those are mostly designed for unit tests and I needed one written specifically for QA Engineers that create \r\nautomated tests. It's Python 2 based.\r\n \r\nI created a tool that suits my needs and maybe it will someone else's too.\r\nI named it TECO (from 2 words: TEst and COverage)\r\n \r\n Below is a GIF presenting it in action, left pane is TECO and righ pane is a sample website and I click its buttons. TECO shows coverage in real time.\r\n \r\n ![alt tag](http://msporna.github.io/public/teco_gif_1.gif.gif)\r\n \r\n \r\n \r\n# FEATURES\r\n- web based dashboard, written in flask\r\n- API written in flask so it can be easily integrated with any CI tool\r\n- live test coverage\r\n- compatible with automated and manual tests\r\n- measures test coverage for js,ts and html files\r\n- works with Angular2 (Typescript)\r\n- measures visited routes\r\n- measures modules that were touched by the tests\r\n- and finally measures efficiency of each test (how many code lines were executed by each test)\r\n- reports are archived\r\n- automatically injects instrumentation function into JS by using provided REGEX + injects .TS module if you are instrumenting typescript source\r\n- easily extensible\r\n \r\n\r\n# DEMO\r\n I recorded a short demo presenting TECO tool in action:\r\n [TECO coverage tool demo](https://youtu.be/xvQJpqtbM0g)\r\n\r\n\r\n# HOW IT WORKS\r\nIt contains javascript file instrument.js that contains instrumentation function. The file is injected into each javascript/typescript/html file specified in config\r\nand instrumentCode function is injected into each executable line of the source you wish. By design, it is injected into functions but as injection is based on REGEX\r\nyou can inject it anywhere you want or simply paste the instrumentation function manually into your source.\r\n \r\nAll of the above happens by running instrument2 python script which also registers few things to backend such as files that you want to instrument, routes\r\nthat app has, modules that app has etc.\r\n \r\nAfter this, you create new test session by calling API function or by using 'start new session' button in the dashboard. Test session must be ended manually (via API call\r\nor UI button) after all of the tests are executed. \r\n \r\nAfter the test session is started, run your tests and each test can, although it's not required, send request to backend with info about current test. Then the test is tied\r\nto instrumentation data gathered and is useful to view in the report to see test efficiency (if some test touches 0 lines of code, then it's not a good test).\r\n \r\nBackend gathers data sent from instrument.js as app code is being triggered by frontend actions performed by the tests. It can be viewed live in the dashboard. \r\nInstrumentCode function sits in executable code lines of your app so everytime you do some action on UI, code underneeth is executed along with the instrumentCode function\r\nthat sends that fact to the backend.\r\n \r\nWhen tests are over, test session ends and we have a test coverage report to analyze.\r\n \r\n ![alt tag](http://msporna.github.io/public/teco_diagram.png)\r\n \r\n# HOW TO USE IT\r\n \r\nYou need automated tests (unless you want to get test coverage for manual ones) and web application you are about to test.\r\n \r\nTo start working with TECO run pip install requirements in the project root\r\nand then create new database by running create_database.py script (/dashboard). \r\n \r\n \r\n### JAVASCRIPT PROJECT\r\n[info] suitable for not-minified javascript files that contain only your team's code (not webpacked etc.) It can be compiled angular app or pure js project- doesn't matter.\r\n \r\n \r\n \r\n- backup your project before start. \r\n- make sure your javascript is not minified or compressed in any way\r\n- find self.REGEX_LIST in instrument2.py and modify regex collection if you need. Typical regex list for javascript files:\r\n```\r\nself.REGEX_LIST=[\r\n            r'function[\\w]*\\([\\w,\\s]*\\) \\{', \r\n            r'function [\\w]+\\([\\w,\\s]*\\) \\{', \r\n            r'function [\\w]+ \\([\\w,\\s]*\\) \\{', \r\n            r'function [\\w]+\\([\\w,\\s]*\\)[\\n]', \r\n            r'[\\w]+.prototype.[\\w]+[\\s]*=[\\s]*function[\\s]*\\(\\)[\\s]*{', \r\n            r'[\\w]+.prototype.[\\w]+[\\s]*=[\\s]*function[\\s]*\\([\\w,\\s]*\\)[\\s]*{',\r\n            r'[\\w]+.[\\w]+[\\s]*=[\\s]*function[\\s]+\\([\\w\\s,]*\\)[\\s]*{']\r\n```\r\n\r\n- find config.json and update:\r\n```\r\nindexPath*\r\nweb_app_root*\r\nJS_TO_INSTRUMENT*\r\nTEMPLATES_TO_INSTRUMENT\r\nROUTES_TO_INSTRUMENT\r\nMODULES\r\n```\r\n*required\r\n \r\n- INJECT_MODE should be 0\r\n- start server from /dashboard by running:\r\n```\r\npython instrument_server.py\r\n```\r\nor execute\r\n```\r\nrun_api_windows.bat\r\n```\r\n- start instrument2.py and pass config.json path as command line argument\r\n- you should get couple of '200's in the output console before it finishes\r\n- check your project's files, should be appended by instrumentation code already plus instrument.js should be inside your app's root and referenced in index.html\r\n- go to localhost:5000/dashboard to view dashboard\r\n- create new test session by clicking the dashboard button or calling api request:\r\n```\r\nhttp://localhost:5000/set_test_session_start?test_session_name=firstSession\r\n```\r\n- in your tests, 2 tweaks should be done\r\nA. make 'set_current_test' request in each test's setup code:\r\n```\r\nhttp://localhost:5000/set_current_test?name=click%on%something%else&test_id=t1-t2-t3-chrome&touched_module=dashboard\r\n```\r\n- params are:\r\n[name] - test name, nvarchar\r\n[test_id] -test id, nvarchar\r\n[touched_module] - module it touches, for example dashboard, nvarchar\r\n- B. in your test teardown, sleep for 3-4 seconds before closing browser to give instrumentCode time to finish sending instrumentation data to backend\r\n- you should see your test session in localhost:5000/dashboard\r\n- click on it to view report; \r\n- now it's a good time to start your tests\r\n- if test session was not ended, there will be a red bar at the top saying it's live\r\n- you should see instrumentation data changing in real time\r\n- end test session after you are done by calling\r\n```\r\nhttp://localhost:5000/set_test_session_end\r\n```\r\n- you now have test coverage report\r\n \r\n \r\n \r\n \r\n### TYPESCRIPT PROJECT\r\n[info] suitable if you use webpack to compile your project and your output javascript contains not only your team's code but also third party code. This makes it hard\r\nto do a test coverage because python script that injects instrumentCode function can't tell which code is which and doing it manually can be impossible task for large\r\nfiles. \r\nSo, you can inject instrumentCode function directly into typescript code of yours (there is typescript module included in this project) and instrument only\r\ncode that comes from your team. After injection, you compile your project as usual but with instrumentCode function injected where needed.\r\n \r\n \r\n \r\n \r\n- backup your project before start.\r\n- find self.REGEX_LIST in instrument2.py and modify regex collection if you need. Tested regex for typescript files:\r\n```\r\nself.REGEX_LIST=[\r\n            r'[\\w]+[\\s]*\\([\\w\\s:,]*\\)[\\s]*{',\r\n            r'[\\w]+[\\s]*\\([\\w\\s,:?]*\\)[\\s]*:[\\s]*[\\w\\<\\>\\[\\]]+[\\s]*{'\r\n            ]\r\n```\r\n\r\n- find config.json and update:\r\n```\r\nindexPath*\r\nweb_app_root*\r\nROUTES_TO_INSTRUMENT\r\nSOURCE_TO_INSTRUMENT*\r\nSOURCE_ABSOLUTE_PATH*\r\nINSTRUMENTER_INSTANTIATE_FILE*\r\nMODULES\r\n```\r\n*required\r\n \r\n- INJECT_MODE should be 1\r\n- start server from /dashboard by running:\r\n```\r\npython instrument_server.py\r\n```\r\nor execute\r\n```\r\nrun_api_windows.bat\r\n```\r\n- start instrument2.py and pass config.json path as command line argument\r\n- you should get couple of '200's in the output console before it finishes\r\n- check your project's files, should be appended by instrumentation code already plus instrument.js should be inside your app's root and referenced in index.html\r\n- compile your .ts code\r\n- copy instrument.js to output folder (dist)\r\n- go to localhost:5000/dashboard to view dashboard\r\n- create new test session by clicking the dashboard button or calling api request:\r\n```\r\nhttp://localhost:5000/set_test_session_start?test_session_name=firstSession\r\n```\r\n- in your tests, 2 tweaks should be done\r\nA. make 'set_current_test' request in each test's setup code:\r\n```\r\nhttp://localhost:5000/set_current_test?name=click%on%something%else&test_id=t1-t2-t3-chrome&touched_module=dashboard\r\n```\r\n- parameters are:\r\n[name] - test name, nvarchar\r\n[test_id] -test id, nvarchar\r\n[touched_module] - module it touches, for example dashboard, nvarchar\r\n- B. in your test teardown, sleep for 3-4 seconds before closing browser to give instrumentCode time to finish sending instrumentation data to backend\r\n- you should see your test session in localhost:5000/dashboard\r\n- click on it to view report; \r\n- now it's a good time to start your tests\r\n- if test session was not ended, there will be a red bar at the top saying it's live\r\n- you should see instrumentation data changing in real time\r\n- end test session after you are done by calling\r\n```\r\nhttp://localhost:5000/set_test_session_end\r\n```\r\n- you now have test coverage report\r\n \r\n \r\n \r\n# COVERAGE REPORT EXPLAINED\r\n\r\n![alt tag](http://msporna.github.io/public/Report-Explained.png)\r\n\r\n## View executed lines\r\n\r\nWhile on report page you can click on instrumented file and a popup with its content will be shown. Instrumentation function\r\nentries that were executed are highlighted so you can easily see what your test triggered and what still needs to be covered.\r\n\r\n![alt tag](http://msporna.github.io/public/FilePreview1.PNG)\r\n\r\n# HOW THE INJECTED CODE LOOKS LIKE\r\n\r\n**javascript - before**\r\n```\r\nfunction function1()\r\n{ \r\n    console.log(\"f1\");\r\n    function3();\r\n}\r\n```\r\n**javascript - after**\r\n```\r\nfunction function1()\r\n{ INSTRUMENTER.InstrumentCode(\"e343fded-aadf-414e-9e46-36095817e052\",\"main.js\");\r\n    console.log(\"f1\");\r\n    function3();\r\n}\r\n```\r\n\r\n**it looks the same in typescript (INSTRUMENTER is instantiated globally).**\r\n \r\n**index.html - before**\r\n```\r\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\r\n<script type=\"text/javascript\" src=\"main.js\"></script>\r\n\r\n<button id=\"testButton1\" onclick=\"function1()\">Button 1</button>\r\n<button id=\"testButton2\" onclick=\"function2()\">Button 2</button>\r\n\r\n<p>output</p>:\r\n<p id=\"output_paragraph\"></p>\r\n\r\n<a href=\"about.html\">go to about</a>\r\n```\r\n**index.html - after**\r\n```\r\n\r\n<script type=\"text/javascript\" src=\"instrument.js\"></script>\r\n<script>var INSTRUMENTER=new jsInstrument(\"http://localhost:5000\",\"set_test_session_start\",\"set_test_session_end\",\"get_js_to_instrument\",\"send_instrumentation_stats\",\"get_test_session_status\");\r\nINSTRUMENTER.InstrumentCode(\"ac88a69c-0d3c-425e-85e8-41cec65f08f5\",\"index.html\");</script>\r\n<script type=\"text/javascript\" src=\"jquery.js\"></script>\r\n<script type=\"text/javascript\" src=\"main.js\"></script>\r\n\r\n<button id=\"testButton1\" onclick=\"function1()\">Button 1</button>\r\n<button id=\"testButton2\" onclick=\"function2()\">Button 2</button>\r\n\r\n<p>output</p>:\r\n<p id=\"output_paragraph\"></p>\r\n\r\n<a href=\"about.html\">go to about</a>\r\n```\r\n\r\n \r\n# CONFIG.JSON ENTRIES EXPLAINED\r\n- **[lines 2-13]** - method names from the API. If API changes those to be updated instead of code\r\n- **[instrumentServerURL]** the dashboard runs on :5000 by default, but if you change it, remember to update this entry\r\n- **[indexPath]** your index.html\r\n- **[web_app_root]** dist folder of your web app, which is served to clients\r\n- **[JS_TO_INJECT]** list of js files that are to be copied and injected into your web app's index.html. Instrument.js is a must\r\n- **[JS_TO_INSTRUMENT]** list of js files where instrumentCode function is injected\r\n- **[TEMPLATES_TOINSTRUMENT]** list of html templates which are being instrumented\r\n- **[ROUTES_TO_INSTRUMENT]** list of routes that can be visited in your website. Instrument tool will determine which ones were visited based on data from js instrumentation function\r\n- **[SOURCE_TO_INSTRUMENT]** source files like typescript - everything that needs to be compiled into js and shaked before use\r\n- **[SOURCE_ABSOLUTE_PATH]** where your source files lie. Fill only if above is filled\r\n- **[INSTRUMENTER_INSTANTIATE_FILE]** a source file where instrumenter module will be instantiated globally. Instantiation code will be appended on the bottom of the file. Fill only if inject mode=1\r\n- **[INJECT_MODE]** currently only 2 modes are here: 0 (js) and 1 (ts)\r\n- **[MODULES]** all modules that your app has. It will be determined what modules were touched by tests and shown in report\r\n \r\n \r\n \r\n \r\n# EXAMPLE\r\nI prepared a sample website and robot framework tests for it to showcase the test coverage tool (inject mode 0, not a typescript project)\r\n \r\nsee readme.txt inside example_app/instructions\r\n \r\n \r\n \r\n# ATTRIBUTIONS\r\nI used following open source project in my project:\r\n1. Flask (http://flask.pocoo.org/)\r\n2. Chart.js (http://www.chartjs.org/)\r\n3. Jquery (https://jquery.com/)\r\n4. Bootstrap (http://getbootstrap.com/)\r\n5. Timer.js (https://husa.github.io/timer.js/)\r\n6. Jquery Datatables (http://www.datatables.net/)\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}